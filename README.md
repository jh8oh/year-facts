# Year Facts
Uses the [Numbers API](http://numbersapi.com/#random/year) to grab interesting facts about years. Built in order to get more familiar with calling APIs from Android.

## Dependencies

| Dependency | Usage | Challenges |
| :---: | :---: | :---: |
| Retrofit | A type safe HTTP client for Android used to call the numbers API | Used in order to call and respond to the Numbers API. Handles the conversion from the JSON file to a Kotlin data class. This dependency was simple to use, but most of the tutorials for it had the actual call being sent from the `Activity` or the `Fragment`. I'm not a huge fan of doing this as I think these classes should only handle the actual UI elements. I had the call being sent from the view model instead as it struck a good balance between handling data and being able to display error messages. In the future, I might need to place the call in a separate class that a `Repository` class can access. This provides a clean API for data access to the rest of the application. |
| Koin | Kotlin injection library used for view model injections | I don't think I've used Koin as much as I would need to in this application in order to get a good grasp of how this dependency handles injections in comparison to Dagger2. However, even the little I've used shows a more concise architecture. I think as I start developing more application, I'd prefer to use Koin as it would mean less boilerplate code (which is exactly what injection is used for). |
| ViewBinding | Obtaining views | With a smaller application with only 2 views, using View Binding over Data Binding seems like a better choice. The advantages of Data Binding comes from its ability to place data values in the XML file, the binding adapters, and the two-way bindings. However, setting them up would require a bit more careful planning with the architecture of the application and more code. For a smaller application where these abilities may be used only a couple of times, the disadvantage that come with a larger dependency files far outway its use. Therefore, View Bindings provides a good way of obtaining views for a small application. |

## Difficulties

One of the difficulties I had with the application was the ability to await for a `MediatorLiveData` to update its data before working with it in the view model (where I shouldn't be observing the livedata). There was a race condition between the `MediatorLiveData` converting the year and era to a signed integer and the network call trying to get the result. The problem was that I didn't want to have to do the network call every time the `MediatorLiveData` changed and so, placing a Transformation that does that wouldn't work. Thus, I needed to find a way to wait for the `MediatorLiveData` to update before continuing with the rest of the function in the IO thread. I did find [a way to do it with the `liveData` function](https://developer.android.com/topic/libraries/architecture/coroutines#livedata) but I decided to go with the simpler method of calculating the signed integer in the same function. 
